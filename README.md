# Technopark-Highload
homework №2 at the course of the technopark highload

### 1. Выбор темы
Сервис для размещения объявлений

### 2. Определение возможного диапазона нагрузок

На 2020 год население России составляет 146,75 млн. По данным с [wiki](https://ru.wikipedia.org/wiki/%D0%AE%D0%BB%D0%B0_(%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81_%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9)) ежемесячная аудитория на Юле составляет 27 млн уникальных пользователей в месяц, что составляет примерно 20% населения России. Всего у Юлы 90 млн. активных пользователей. Среднее значение RPS = 12 тыс.

Основные действия на сайте [Юла](https://youla.ru/):
* регистрация и авторизация
* работа с профилем
* просмотр, создание и редактирование объявлений
* список новых объявлений, поиск по ключевым словам и категориям
* чат
* лайки, отзывы

### 3. Выбор планируемой нагрузки

Исходя из приведенной статистики для Юлы определим возможный диапазон нагрузки на нашем сервисе следующим образом:
* составляет 40 млн. уникальных пользователей в месяц
* 120 млн. активных пользователей
* среднее значение RPS = 20 тыс.

### 4. Логическая схема базы данных

Выделим основные сущности в нашем проекте: пользователь, объявление, категория, отзыв, чат и сообщения. На рисунке отображены поля моделей и заданы отношения между каждой из моделей.

![](files/models.jpg)

Стоит отдельно пояснить про механику взаимодействия между некоторыми моделями.
Так, например, "отзыв" имеет связь с "пользователем" и "объявлением", по причине того, что покупатель может оставить отзыв только после успешной покупки на нашем сервисе.
Модель "категория" наглядно представить в виде дерева, в котором родительские категории указывают на дочерние (например, животные -> кошки -> британская порода).
А связь "чат", "пользователь" и "объявление" установлена, потому что каждое объявление имеет уникальный чат с покупателем и продавцом, и создается в случае инициативы покупателя или постановки лайка.

### 5. Физическая системы хранения

Активные сессии пользователя будем хранить в redis. Redis отличается от существующих решений тем, что
API для работы с Memcached (MemcacheDB) позволяет хранить массивы, но эти массивы будут сериализованы и сохранены как строки, таким образом атомарные операции над такими массивами не возможны.
Redis позволяет хранить как строки, так и массивы, к которым можно применять атомарные операции pop / push, делать выборки из таких массивов, выполнять сортировку элементов, получать объединения и пересечения массивов, что придет большую гибкость нашему приложению.

Высокая скорость работы Redis обеспечивается тем, что данные хранятся в оперативной памяти и сохраняются на диск либо через равные промежутки времени, 
либо при превышении определённого количества не сохранённых запросов. 
Из этого вытекает, что используя Redis, можно потерять результаты нескольких последних запросов, что вполне приемлемо для большинства веб-приложений, учитывая, что обращение к
Redis по скорости сравнимо с обращением к оперативной памяти. Тем не менее, потерь можно избежать через избыточность - Redis поддерживает неблокирующую master-slave репликацию.
Нагрузочное тестирование: 11 к. запросов SET в секунду, 81 к. запросов GET в секунду на Linux-сервере.

Данные о пользователе и активных объявлениях имеют для нас наибольший приоритет, потому что без них наше приложение потеряет ключевой функционал.
Для хранения этих данных я выбрал PostgreSQL, потому что по сравнению с другими реалиционными аналогами она имеет наиболее обширный функционал, эффективную репликацию и достаточно удобную поддержку.

Для повышения отказоустойчивости нашего приложения будем хранить пользователей, объявления и прочую информацию на разных шардах, что сделает компоненты нашей системы независимыми и выход из стоя одной компоненты не приведет к полной деградации всего сервиса.

Для хранение изображений воспользуемся услугами облачного провайдера Amazon. Это решение является лучшим на рынке и по данным с официального сайта обеспечивает надежность 11 девяток. 

### 6. Выбор прочих технологий

##### Языки программирования

Backend - Golang. Язык предоставляет эффективный параллелизм, такой как C, C ++, Java, в то же время параллелизм в Go осуществляется намного проще благодаря горутинам, каналам и сборке мусора. Он имеет об обширную стандартную библиотеку, а также утилиты для форматирования кода, тестирования и расчета покрытия прямо из коробки. В нем очень удобно построена интеграция с внешними зависимостями посредствам go.mod. Go быстрый, кроссплатформенный, open-source с относительно низким порогом вхождения.
Для работы с базой данных будем использовать фрейморк GORM. Для работы с протоколом http фреймворк роутер echo. Для работы стандартную библиотеку grpc-go. 

Frontend - HTML, CSS, TypeScript. Для  TypeScript будем использовать фреймворк React, который обеспечивает модульность, быстрый рендеринг, высокую run-time производительность. В сочетании с ES7 ReactTS может легко работать при высоких нагрузках. Также он имеет virtual DOM, которая позволяет упорядочивать документы форматов HTML, XHTML или XML в дерево, которое лучше всего подходит браузерам для анализа различных элементов веб-приложения.
	
##### Протоколы взаимодействия

Протокол связи между фронтендом и бэкендом - https, данные будут передаваться в формате json. 

Общение между микросервисами на бэкенде будет осуществляться по протоколу gRPC, данные будут передаваться в формате protobuf

##### Обеспечение качества

Как на фронтенде, так и на бэкенде будут использованы статические и динамические анализаторы кода, интеграционные и юнит тесты. Их запуск будет автоматизирован в Gitlab CI при открытии merge request в master.

##### Релиз процесс

Будем собирать rpm пакеты для наших сервисов. Каждый пакет будет иметь собственную уникальную версию. 
Сервисы будут деплоиться в kubernetes. Пайплайн раскладки в k8s будет состоять из нескольких этапов: dev, staging, prod, 
на каждом из которых можно убедиться в корректности работы сервиса, правильности заправленных хостов и.п.

Базы данных будут работать на "голом" железе, их конфиги будут доставляться по средствам puppet.

### 7. Расчет нагрузки и потребного оборудования

##### Активные сессии

Данный компонент архитектуры особо важен по той причине, что валидация cookie пользователей осуществляется на каждый запрос.
В среднем одна запись об активных сессиях может занимать до 30 байт. Количество запросов к ней можно сопоставить с общим rps на весь проект (20 тыс). Умножим это на 120 млн. активных пользователей получим итоговый объем занимаемых данных - 3.6 млрд. байт.

##### Пользователи

Одна запись пользователя в таблице занимает примерно 200 байт. Тогда общий объем занимаемой памяти составит 24 млрд. байт.

##### Объявления

Запись с одним объявлением может занимать до 900 байт. Исходя из этого общий объем занимаемого места примерно равен 650 млрд. байт.

##### Фото

В среднем одна фотография весит около 500 кб. 
Если считать что у каждого пользователя есть аватарка, и каждому объявлению приложено в среднем 5 фото, то получим 360 трлн. байт.

##### Прочее

Сообщения, загрузка чатов и отзывы являются наименее редкими операциями в нашем веб-приложении, 
потому что большинство пользователей предпочитают связываться с покупателем по номеру телефона. Объем памяти на их хранение можно оценить примерно в 15 млрд. байт.

##### Расчет потребного оборудования

Исходя из приведенных выше данных нам потребуется 362 тб. для хранения всей нужной информации. При закупке тазов со следующими характеристиками:

| CPU  (cores)  |      RAM (gb)    |  SSD (gb) |
|:----------:|:-------------:|:------:|
| 32 |  64 | 4096 |

с учетом 30% ежегодного прироста пользователей, нам потребуется 95 тачек под хранилища, 15 под микросервисы на бэкенде и 4 для фронтенда.

### 8. Выбор хостинга / облачного провайдера и расположения серверов

При покупке облачных серверов нет необходимости в аппаратной поддержке и найме сис. админов поэтому я решил смотреть в сторону облачных решений 
и в качестве провайдера выбрал MCS, потому что он обеспечивает весь нужный функционал:
 * поддержка kubernetes из коробки
 * быстрая миграция без остановки приложения
 * удобное масштабирование
 * оперативная тех. поддержка

### 9. Схема балансировки нагрузки (входящего трафика и внутрипроектного, терминация SSL)

Будем использовать nginx для балансировки нагрузки с использованием схемы L7. Это позволит равномерно распределить нагрузку и решит проблемы медленных клиентов. Также nginx имеет внутренние инструменты для настройки SSL терминации.

### 10. Обеспечение отказоустойчивости

Поскольку запросов на чтение в нашем сервисе приходит в разы больше чем, на изменение, то для обеспечения отказоустойчивости баз данных будет резонно поднять для каждого мастера по два слейва. 
Отказоустойчивость наших сервисов обеспечивается за счет развертки в k8s, так как внутри него можно настроить автоматическую балансировка нагрузки с помощью постоянного мониторинга сведений о производительности и использовании ресурсов и соответствующее распределение работающих приложений по всему виртуальному кластеру.  
